/*
    1. Создайте представление, в которое попадут автомобили стоимостью до 25 000 долларов 
    2. Изменить в существующем представлении порог для стоимости: пусть цена будет до 30 000 долларов (используя оператор OR REPLACE) 
    3. Создайте представление, в котором будут только автомобили марки “Шкода” и “Ауди” 
    4. Добавьте новый столбец под названием «время до следующей станции». Чтобы получить это значение, мы вычитаем время станций для 
    пар смежных станций. Мы можем вычислить это значение без использования оконной функции SQL, но это может быть очень сложно. 
    Проще это сделать с помощью оконной функции LEAD . Эта функция сравнивает значения из одной строки со следующей строкой, чтобы 
    получить результат. В этом случае функция сравнивает значения в столбце «время» для станции со станцией сразу после нее.
    --------------------------------------------------------------------------------------------------------------------------------
	Для решения задач используйте базу данных lesson_4 (скрипт создания, прикреплен к 4 семинару). 
    5. Создайте представление, в которое попадет информация о  пользователях (имя, фамилия, город и пол), которые не старше 20 лет.
	6. Найдите кол-во,  отправленных сообщений каждым пользователем и  выведите ранжированный список пользователей, указав имя и 
    фамилию пользователя, количество отправленных сообщений и место в рейтинге (первое место у пользователя с максимальным количеством 
    сообщений). (используйте DENSE_RANK)
	7. Выберите все сообщения, отсортируйте сообщения по возрастанию даты отправления (created_at) и найдите разницу 
    дат отправления между соседними сообщениями, получившегося списка. (используйте LEAD или LAG)
*/

CREATE DATABASE IF NOT EXISTS hw_5;
USE hw_5;

CREATE TABLE cars
(	id INT NOT NULL PRIMARY KEY,
    name VARCHAR(45),
    cost INT);

INSERT cars
VALUES
	(1, "Audi", 52642),
    (2, "Mercedes", 57127 ),
    (3, "Skoda", 9000 ),
    (4, "Volvo", 29000),
	(5, "Bentley", 350000),
    (6, "Citroen ", 21000 ), 
    (7, "Hummer", 41400), 
    (8, "Volkswagen ", 21600);
    
SELECT * FROM cars;

-- 1. Создайте представление, в которое попадут автомобили стоимостью до 25 000 долларов
ALTER VIEW cars_cost AS 
(	SELECT * 
	FROM cars 
	WHERE cost < 25000);
SELECT * FROM cars_cost;


-- 2. Изменить в существующем представлении порог для стоимости: пусть цена будет до 30 000 долларов (используя оператор OR REPLACE)
CREATE OR REPLACE VIEW cars_cost AS
(	SELECT *
    FROM cars 
    WHERE cost < 30000);
SELECT * FROM cars_cost;


-- 3. Создайте представление, в котором будут только автомобили марки “Шкода” и “Ауди” 
CREATE OR REPLACE VIEW cars_model AS
(	SELECT *
    FROM cars 
    WHERE name IN ("Skoda", "Audi"));
SELECT * FROM cars_model;


-- 4. Добавьте новый столбец под названием «время до следующей станции»

CREATE TABLE IF NOT EXISTS trains 
( 	train_id INT,
	station VARCHAR(20),
	station_time TIME);
 
INSERT INTO trains(train_id, station, station_time) VALUES
	(110, 'San Francisco', '10:00:00'),
	(110, 'Redwood City', '10:54:00'),
	(110, 'Palo Alto', '11:02:00'),
	(110, 'San Jose', '12:35:00'),
	(120, 'San Francisco', '11:00:00'),
	(120, 'Palo Alto', '12:49:00'),
	(120, 'San Jose', '13:30:00');

SELECT * FROM trains;

SELECT *,
SUBTIME(LEAD(station_time) OVER(PARTITION BY train_id ORDER BY train_id), station_time)
AS time_to_next_station
FROM trains;



-----------------------------------------------------------------------------------------------------------------------------------------



USE vk;
SELECT * FROM vk;


--  5. Создайте представление, в которое попадет информация о  пользователях (имя, фамилия, город и пол), которые не старше 20 лет.

CREATE OR REPLACE VIEW users_under_20 AS 
SELECT CONCAT(firstname, " ", lastname) AS "Пользователи младше 20 лет",
hometown,
gender
FROM users u
JOIN profiles p ON u.id = p.user_id
WHERE TIMESTAMPDIFF(YEAR, birthday, NOW()) < 21
GROUP BY u.id;

SELECT * FROM users_under_20;
DROP VIEW users_under_20;


/* 6. Найдите кол-во,  отправленных сообщений каждым пользователем и  выведите ранжированный список пользователей, 
	указав имя и фамилию пользователя, количество отправленных сообщений и место в рейтинге (первое место у 
    пользователя с максимальным количеством сообщений). (используйте DENSE_RANK) */

SELECT 
	DENSE_RANK() OVER (ORDER BY COUNT(from_user_id) DESC) AS "Место в рейтинге",
	CONCAT(firstname, " ", lastname) AS "Пользователь",
    COUNT(from_user_id) AS "Количество сообщений"
FROM users u
JOIN messages m ON u.id = m.from_user_id
GROUP BY u.id;


/* 7. Выберите все сообщения, отсортируйте сообщения по возрастанию даты отправления (created_at) и найдите разницу 
    дат отправления между соседними сообщениями, получившегося списка. (используйте LEAD или LAG) */

SELECT 	
	body,
    created_at,
    TIMEDIFF(created_at, LAG(created_at) OVER()) AS next_message
FROM messages
ORDER BY created_at;